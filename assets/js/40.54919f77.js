(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{404:function(e,a,s){"use strict";s.r(a);var n=s(44),t=Object(n.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"webpack优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#webpack优化"}},[e._v("#")]),e._v(" webpack优化")]),e._v(" "),s("ol",[s("li",[e._v("提高 Webpack 打包速度\n"),s("ol",[s("li",[e._v("优化Loader搜索范围，指定哪些文件不通过loader处理")]),e._v(" "),s("li",[e._v("cache-loader缓存loader处理结果，这样下次打包可以直接使用缓存结果而不需要重新打包")]),e._v(" "),s("li",[e._v("多线程处理打包\n"),s("ol",[s("li",[e._v("HappyPack，rules匹配文件，plugins配置loader和拆分多少个子进程")]),e._v(" "),s("li",[e._v("thread-loader放置在其他 loader 之前， thread-loader 不是越多越好，也请只在耗时的loader 上使用。")]),e._v(" "),s("li",[e._v("在Webpack3 中，我们一般使用 UglifyJS 来压缩代码，但是这个是单线程运行的，也就是说多个js文件需要被压缩，它需要一个个文件进行压缩，webpack-parallel-uglify-plugin 插件，该插件会开启多个子进程，把对多个文件压缩的工作分别给多个子进程去完成，但是每个子进程还是通过UglifyJS去压缩代码。无非就是变成了并行处理该压缩了，并行处理多个子任务，提高打包效率。来并行运行 UglifyJS，从而提高效率。在 Webpack4 中，我们就不需要以上这些操作了，只需要将 mode 设置为 production 就可以默认开启以上功能。")])])]),e._v(" "),s("li",[e._v("DllPlugin & DllReferencePlugin"),s("br"),e._v("\nDllPlugin可以将特定的类库提前打包成动态链接库，当需要导入的模块在动态连接库里的时候，模块不用再次被打包，而是去动态连接库里获取。\n这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。\n"),s("code",[e._v("webpack --config webpack.dll.js --mode development")]),e._v(" 生成依赖文件用 DllReferencePlugin 将依赖文件引入项目中")]),e._v(" "),s("li",[e._v("noParse用于配置那些模块文件的内容不需要进行解析（即无依赖） 的第三方大型类库（例如jquery,lodash）等，使用该属性让 Webpack不扫描该文件，以提高整体的构建速度。")]),e._v(" "),s("li",[e._v("IgnorePlugin 忽略某些特定的模块，让webpack 不把这些指定的模块打包进去。")])]),e._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 参数中第一个参数是匹配引入模块路径的正则表达式，第二个参数是匹配模块的对应上下文，即所在目录名。")]),e._v("\nplugins"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("webpack"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("IgnorePlugin")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token regex"}},[s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[e._v("^\\.\\/locale")]),s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),s("span",{pre:!0,attrs:{class:"token regex"}},[s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")]),s("span",{pre:!0,attrs:{class:"token regex-source language-regex"}},[e._v("moment$")]),s("span",{pre:!0,attrs:{class:"token regex-delimiter"}},[e._v("/")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br")])]),s("ol",{attrs:{start:"7"}},[s("li",[e._v("打包文件分析工具webpack-bundle-analyzer 插件的功能是可以生成代码分析报告，帮助提升代码质量和网站性能。")]),e._v(" "),s("li",[e._v("费时分析speed-measure-webpack-plugin，打包速度测量插件。这个插件可以测量webpack构建速度，可以测量打包过程中每一步所消耗的时间，然后让我们可以有针对的去优化代码。")]),e._v(" "),s("li",[e._v("resolve.extensions：用来表明文件后缀列表，默认查找顺序是 ['.js', '.json']，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面")]),e._v(" "),s("li",[e._v("resolve.extensions：用来表明文件后缀列表，默认查找顺序是 ['.js', '.json']，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面")])])]),e._v(" "),s("li",[e._v("减少 Webpack 打包后的文件体积\n"),s("ol",[s("li",[e._v("对图片进行压缩和优化image-webpack-loader这个loder可以帮助我们对打包后的图片进行压缩和优化")]),e._v(" "),s("li",[e._v("删除无用的CSS样式purgecss-webpack-plugin可以去除未使用的CSS,此插件必须和CSS代码抽离插件mini-css-extract-plugin配合使用。")]),e._v(" "),s("li",[e._v("以CDN方式加载资源：一般常用的类库都会发布在CDN上，因此，我们可以在项目中以CDN的方式加载资源，这样我们就不用对资源进行打包，可以大大减少打包后的文件体积。使用到add-asset-html-cdn-webpack-plugin插件")]),e._v(" "),s("li",[e._v("开启Tree Shaking删除代码中未被引用的代码，在webpack4中，当我们将mode设置为production时，会自动进行tree-shaking。")]),e._v(" "),s("li",[e._v('开启Scope Hoisting可以让 Webpack 打包出来的代码文件更小、运行的更快， 它又译作 "作用域提升"，是在 Webpack3 中新推出的功能。在webpack4中，当我们将mode设置为production时会自动开启。')]),e._v(" "),s("li",[e._v("按需加载 & 动态加载")])])])])])}),[],!1,null,null,null);a.default=t.exports}}]);